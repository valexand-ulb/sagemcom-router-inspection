#!/bin/sh /etc/rc.common
# Copyright (C) 2011 Sagemcom
START=14
STOP=98

. /etc/sysdirs.conf
. /etc/gui-core.conf
. /etc/flash-map.conf

UBIDEV=/dev/ubi0
LIGHTTPD_VERSION=/etc/lighttpd/conf.d/gui-version.conf

ROOT_FILESYSTEM_FORMAT=`cat /proc/cmdline | grep squashfs`

init_ubi () {
  if [ x"$CONFIG_MTD_SECURE_UPDATE_UBI" != x"" ]; then
    for vol in /sys/class/ubi/ubi0/ubi0_*
    do
      if [ `cat $vol/name` = "$1" ]; then
        basename $vol
        return 0
      fi
    done
    # Try to create the volume
    VOL_SIZE=`expr $CONFIG_MTD_SECURE_UPDATE_GUI_SIZE "*" $CONFIG_MTD_SECURE_UPDATE_LEB_SIZE`
    if (ubimkvol "$UBIDEV" -N "$1" -s "$VOL_SIZE" -t static > /dev/null); then
      for vol in /sys/class/ubi/ubi0/ubi0_*
      do
        if [ `cat $vol/name` = "$1" ]; then
          basename $vol
          return 0
        fi
      done
      return 1
    fi
    echo "Cannot create UBI volume for $1 !" >&2
    return 1
  fi
}

find_mtd () {
  (cat /proc/mtd | \
    grep "\"$1\"" | \
    cut -d ":" -f 1 | \
    sed -e 's/^mtd\([0-9]*\)$/\/dev\/mtdblock\1/' ) 2> /dev/null \
    || echo "" ;
}

check_image () {
  if [ -x /usr/sbin/gsdf-verif ]; then
    /usr/sbin/gsdf-verif "$1" 2> /dev/null 1> /dev/null
    if [ $? -eq 0 ]; then
      echo "Valid GUI image"
      # Check the GUI firmware version
      GUI_FIRMWARE_VERSION=`head -c 42 $UBI_DEVICE | tail -c 10 2> /dev/null`
      GUI_VERSION_COMPACT=`echo -n "$GUI_FIRMWARE_VERSION" | grep -qE "^[0-9]\.[0-9]\.[0-9]$" ; echo -n $?`
      if [ "$GUI_VERSION_COMPACT" -eq 0 ]; then
        # Classic version format
        GUI_VERSION=`echo -n "$GUI_FIRMWARE_VERSION" | sed -e 's/\.[0-9]*$//'`
        API_VERSION=`echo -n "$GUI_API_VERSION"`
      else
        # Compact version format
        GUI_VERSION=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 5-6 | sed -e 's/^0*//'`
        API_VERSION=`echo -n "$GUI_API_VERSION" | sed -e 's/^0*//' | sed -e 's/\..*$//'`
      fi
      #if [ "$GUI_VERSION" != "$API_VERSION" ]; then
      #  echo "Invalid GUI version: $GUI_VERSION (GUI version=$GUI_FIRMWARE_VERSION, API version=$GUI_API_VERSION) !"
      #  return 1
      #fi
      #Generate the lighttpd version config
      echo "# Generated by gui-firmware" > $LIGHTTPD_VERSION
      if [ "$GUI_VERSION_COMPACT" -eq 0 ]; then
        # Classic version format
        GUI_VERSION_REGEXP=`echo -n "$GUI_FIRMWARE_VERSION" | sed -e 's/\./\\\./g'`
        echo "var.version = \"$GUI_FIRMWARE_VERSION\"" >> $LIGHTTPD_VERSION
        echo "var.version_expr = \"$GUI_VERSION_REGEXP\"" >> $LIGHTTPD_VERSION
      else
        # Compact version format
        GUI_MINOR=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 7-8 | sed -e 's/^0*//'`
        GUI_REVISION=`echo -n "$GUI_FIRMWARE_VERSION" | cut -c 9-10 | sed -e 's/^0*//'`
        echo "var.version = \"$GUI_VERSION.$GUI_MINOR.$GUI_REVISION\"" >> $LIGHTTPD_VERSION
        echo "var.version_expr = \"$GUI_VERSION\\.$GUI_MINOR\\.$GUI_REVISION\"" >> $LIGHTTPD_VERSION
      fi
      return 0
    elif [ `find /usr/share/gui-*/www/gui/version.txt` ]; then
        echo "# Generated by gui-firmware from /usr/share/gui-*/www/gui/version.txt" > $LIGHTTPD_VERSION
        GUI_FIRMWARE_VERSION=`cat /usr/share/gui-*/www/gui/version.txt`
        GUI_VERSION_REGEXP=`echo -n "$GUI_FIRMWARE_VERSION" | sed -e 's/\./\\\./g'`
        echo "var.version = \"$GUI_FIRMWARE_VERSION\"" >> $LIGHTTPD_VERSION
        echo "var.version_expr = \"$GUI_VERSION_REGEXP\"" >> $LIGHTTPD_VERSION
    else
      echo "Invalid RSA or empty external GUI image"
      RESULT=1
    fi
  else
    echo "'gsdf-verif' unavailable, try 'checkfirmware'"
    RESULT=0
  fi
  if [ -x /usr/bin/checkfirmware ]; then
    /usr/bin/checkfirmware "$1" 2> /dev/null 1> /dev/null
    if [ $? -eq 0 ]; then
      echo "Valid firmware image"
      return 0
    else
      echo "Invalid DSA or empty external GUI image"
      return 1
    fi
  else
    if [ $RESULT -ne 0 ]; then
      echo "'checkfirmware' unavailable, not checking image"
    fi
  fi
  return $RESULT
}

mount_squashfs () {
  mount -t squashfs $1 $2 2> /dev/null
}

mount_gui () {
  UBI_DEVICE=/dev/`init_ubi "$1" "$2"`
  # Check the GUI firmware device
  if !(check_image "$UBI_DEVICE"); then
    return 1
  fi
  # Mount squashfs on the block device
  GUI_DEVICE=`find_mtd "$3"`
  if [ x"$GUI_DEVICE" != x"" ]; then
    if !(mount_squashfs $GUI_DEVICE $4); then
      echo "Cannot mount SQUASHFS ($GUI_DEVICE) on $4 !"
      return 1
    fi
    return 0
  else
    echo "No $1 MTD device !"
    return 1
  fi
}

start() {
  # GUI core libraries from rootfs
  UNION_OPT=$GUI_CORE
  # Add GUI from /opt/data
  for gui in /opt/data/gui-*/www
  do
    if [ -d $gui ]; then
      # Add GUI check here !!!
      UNION_OPT="$gui":"$UNION_OPT"
    fi
  done
  # Try to mount the externalized GUI filesystem
  VOL_SIZE=`expr $CONFIG_MTD_SECURE_UPDATE_GUI_SIZE "*" $CONFIG_MTD_SECURE_UPDATE_LEB_SIZE`
  if [ x"$CONFIG_MTD_SECURE_UPDATE_GUI_PARTITION" != x"" ] && \
     (mount_gui "gui" "$VOL_SIZE" "guifs" "$GUI_DIR"); then
    echo "Install externalized GUI (mount $GUI_DIR)"
    UNION_OPT="$GUI_DIR":"$UNION_OPT"
  fi
  # Include supported data models
  if [ -d /etc/gui/conf.d ]; then
    for guiconf in /etc/gui/conf.d/*
    do
      if [ -f "$guiconf" ]; then
        . "$guiconf"
      fi
    done
  fi
  if [ $UNION_OPT != $GUI_CORE ]; then
    mkdir /www 2> /dev/null
    SQUASHFS_MOUNT_POINT=`grep "/dev/root" /proc/mounts |cut -d" " -f2`
    UNION_OPT=`echo $UNION_OPT | tr '/' '@' | sed s#@usr@share#$SQUASHFS_MOUNT_POINT/usr/share#g | tr '@' '/'`
    if [ x"$CONFIG_OVERLAYFS_FS" != x"" ]; then
		FIRST=`echo $UNION_OPT | cut -d':' -f1`
		OTHERS=`echo $UNION_OPT | cut -d':' -f2-`
		mount -t overlayfs -r -o lowerdir=$FIRST,upperdir=$OTHERS overlayfs $WWW_DIR
	 else
  	   mount -t unionfs -o ro,dirs="$UNION_OPT" none "$WWW_DIR"
	 fi
  else
    rm -fr /www
    ln -s $UNION_OPT /www
  fi
}

stop() {
  echo "Umount GUI file systems"
  umount "$WWW_DIR" 2> /dev/null || echo "Cannot umount $WWW_DIR !" >&2
  if [ x"$CONFIG_MTD_SECURE_UPDATE_GUI_PARTITION" != x"" ]; then
    umount "$GUI_DIR" 2> /dev/null || echo "Cannot umount $GUI_DIR !" >&2
  fi
}

restart() {
  stop
  start
}


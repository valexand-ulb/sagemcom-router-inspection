QP !)
@(!$
@ !<
@ !$
@ !$
@ !$
$B"4
$B& 
$B't
$B#4
@0!<
$D	`
 $E)
@(!$
$B; 
$B d
$B d
$BC4
$BC4
@ !$
$BKp
`L4BQ
 $B)
$BP@
@ !$
@ !$
$B\t
$BOp
$BR 
$BTh
$BiX
 $B t
$BKp
$BKp
$BKp
$BKp
$Bc<
$BKp
$BKp
$BKp
$BKp
$BKp
@(!$
@(!$
@(!$
@(!$
@(!$
@(!$
$Bj 
@ !$
$Bvp
@ !$
@ !$
@ !$
$Bw$
@ !$
$Bw$
@ !$
@ !$
$Bw$
 $B%
 $B+<
@ !$
@ !$
@ !$
@ !$
@ !$
@ !$
@ !$
@(!$
@(!$
$D%@
$D%l
$D&8
$E&H
@(!'
$D&X
$d&p
$D&8
@ !'
$E' 
$D',
$D',
$D'\
$d($
$D(4
$D(@
$D(D
$d(d
`(!'
$D',
$E' $
$D) 
$D&8
$D',
$D*<$
$D*T
$E+4
$d',
$E+<
$D',
$E+D$
$d+H
$D+x
$D1<
@(!$
@(!$
$D2(
$d2H
$D2`
$e3$
$d3(
$e3$
$d38
$e3$
$d3H
$D3X
$E3`
$E3h
$E3p
$D3x
b(!'
$B5 
$B5(
$d5,
$E3`$
$E50
$E58$
$E5@$
$E58$
$B58
$B5@
$E5H
$E5P
$E5T
$E50
$E5X
$D5`
$C58
$B5 
$B5(
$E64
$d6<
$d6@
$B6<
$B6@
$d6D
$E5H
$E5P
$E5T
$D;(
$$B,D
$D;<
$D;<
$D;H
$D;`
$$B,D
$$B9
$$B9
$$B9
@ !'
@ !'
@ !'
@ !'
@ !'
@(!$
@(!$
@(!$
$$B7
$d=(
$$B>
$$B>
$E>,
$E>4
$E><
$D>P
$E>h
$D>t
@(!$
$E?(
@(!$
$B?4
$E?@
$d?D
@(!$
$D?L
$d?|
$d@ 
$F@`$
$e@p
$d@t
@0!<
$d@ 
$F@`$
@(!<
$e@p
$d@t
@(!$
$DA8
$dA\
$F@`$
 $D+
 $E+
$DEp
$DEx
$B%H
$B!t
$dG 
$dG<
$dGX
$dGt
$DHP
$$Bd
$dHT
$DH|
$dI0
$dIX
$DJ,$
$dJT
$dJ|
$$Bg
$$Bh
$DK(
$DKH
$$Bl
$DKX
$BKt
$BK|
$$Bq
$DL 
$DL<
$$Bq
$DLp
$$Bq
$DM,
$DMP
$DM\
@(!$
$dND
$BN`
$BNh
$BNl
$$B~
$$Bk
$DO 
$EO4$
$DO 
$DO<
$BO@
$dQ`
@(!$
@(!$
$DS`
$DSh
	i@1
Y@1N
$dT`
$DTl
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $C,
 $C,
 $B,
 $B,
 $C,
 $B,
 $C,
 $C,
 $B,
 $B,
 $B,
 $C,
 $C,
 $B,
 $B,
 $B,
 $B,
 $B,
 $C,
 $C,
 $B,
 $C,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $C,
 $B,
 $C,
 $B,
 $B,
 $C,
 $C,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
 $B,
@(!$
@(!$
@(!<
$DU,
@(!<
$dU8
$DUx
$DU,
4cpH
@0!<
@(!<
@(!<
@(!<
4cp8
@ !$
$B 8
$DZ0
$dZD
$dZ\
$DZt
$B$p
$D[L
$F[X
 $d1
 $d0
 $d1
 $d2
$B$p
$D\ 
@ !$
$d\<
@(!$
@(!$
@(!$
@(!$
@(!$
@(!$
$D]<
$D]l
$D^P
@(!$
$D^h
@(!$
$F_0
$D_8
$E_`
$D`H
$Ba(
$Ba,
$BaD
$BaP
$Ba`
$Bat
$Bb 
$Bb,
$Bb8
$BbD
$BbP
$Db\
$Dbt
$Db\
$Db\
$Dd(
$DdP
$Ddx
$De$
$De,
$De8
$De@
$BeP
$De\
$dex
$FeP
$dex
$FeP
$dex
$FeP
$De|
,$B)
,$B)
,$B)
 $B&
 $B&
,$B-h
$Ef8
@(!$
,$B70
!pt`
/h!q
Oh!q
!pup
!pvP
!pup
!pvP
!pup
!pvP
!pup
!pvP
!pup
!pvP
!pyx
!ptp
jP+2
!pvP
x!39
x!pyp
LP!%k
h+-q
MP!%)
x+ptP
.h!q
!pvP
!ptx
*P+2
!pvP
x!39
x!py
RP+q
LP!%k
h+-p
MP!%)
	H+$c
IP!$
8!'9A@
0!'9A@
 !$B
 !0B
@(!$c
 !$c
(!0F
(#pf@
P+$c
8+%)
 !0B
 !,D
!pC(
,pC 
PpC8
0!'9M
0!'9M
0!'9M
0!'9M
0!'9M
0!'9M
0!'9M
<'9M
0!'9M
(!&&
(!&&
  !,B
  !,B
 !,B
 !,B
gE4B#
24BTv
6|4B
0p4B
4BY9
hX4B
j	4B
<n4B
h%5k/
@%5kD
l`%<
0%6R
%<	v
p!5)
6ssT
FP&6
'8%<
75Jl
%<	'H
]@5)wL
X%4B
JP%4
+X%6
CP&<
`(!$
 !'9
(!&F
 !&Q
8!'9
@0!&$
@(!,G
@0!&
@(!&
`8!$
$c(l
@8!$
$B(8
 !&R	|
(!'9
 (!'9
@ !$
@ !$
(!'9
(!'9
 !'9
@ !&
8!'9	
`(!'9
(!'9
(!'9
 !$h
(!'9
(!'9
@ !'9
 !$B
@ !'9
H!-"
`h!$
'H!$
0$B'
0$B'
0$B,
0$B-
0$B;H
0$B-
0$B-H
0$c0@
0$c5
0$c7\
0$c2P
0$c8
0$c4
0$c4
0$c:X
0$c:
0$c4
0$c5t
0$c@$
0$c>
0$c?
0$c@|
0$cAX
0$c;H
0$B/\
0$B.p
$DhL
$dhh
$Di 
0$B/\
$di(
0$B/\
$di|
0$B,
0$BC
0$BP
$Dj,
$Dj`
0$BY 
0$BY 
	PB$
0$Ba
0$Ba
0$Ba
0$BT(
0$BW
`@$	
0$Bd
0$Bf
` !$
P@$	
0$Ba
0$BT(
0$Bk
0$Bk
P@$	
$Dkp
` !$
@(!$
0$Bb
$DlX
0$Bgh
0$Bgh
0$B^
0$B^
0$BqL
0$BqL
P@$	
P@$	
P@$	
P@$	
P@$	
@ !$
0$B|
0$Bb
0$Bp
0$B}T
0$BqL
0$BqL
 $c4
 $c4
 $E4@
 $c4
 $c4
 $B3
 $B3
 $B3X
 $B3
@ !$
$Dq(
$DqD
$Dr,
$DrH
$Drp
`(!$
`(!$
`(!$
`0!$
`0!$
p!pO 
$Ds 
` !$
` !$
p!pO 
` !$
` !$
$DsP
4$B 
4$B 8
4$B!
$Dtt
 $c9
 $c<(
 $c>p
 $c@
$Du8
$du|
4$B9
4$B9
4$B9
4$B9
4$B<
4$B:
4$B;
4$B<
@ !$
` !$
4$BJX
4$BK0
4$BK0
4$B:
$DvD
4$BG
4$B:
4$B:
4$B;T
4$B=h
$dvp
4$B<
4$BK
4$BI8
` !$
4$B@H
4$B:
4$BG
4$B>
4$B@H
4$BK
$Dw8
4$BK
@ !$
4$BK0
4$BJX
4$B:
$Dw`
4$BG
4$B>
4$BI8
4$B@H
4$BR
4$BI8
4$B@H
$dx 
$dxH
$dxl
4$BC
$DyD
$Dyx
@@4c
$DzX
$Dzp
4$B8 
4$B8
4$B:X
 $Bd
 $ddT
 $BdP
 $DdT
$E{ 
 $cdP
4$BZL
4$BX
 $cdP
4$Bb
$D{4
4$BU
$D{`
4$BN
4$B:
4$B:
4$B;T
4$B=h
$dvp
4$B<
4$B<
4$BoP
4$BI8
`(!$
`(!$
`(!$
$D|8
$D|8
$D|H
$d|L
$D|x
@ !$
` !$
@ !'
4$BJX
4$BK0
4$B:
` !$
@ !$
4$BJX
4$BK0
4$B:
4$B{\
$D}8
4$ci
4$ckX
4$cl
4$cl
4$cr
4$cyT
4$cy
4$cz0
4$cn
4$coP
4$cn
4$cm
4$cr
4$cx
4$cz
4$cz
4$cl
4$Bg`
4$c{\
$D}X
$Bm$
@ !$
@ !$
@ !$
@ !$
` !$
PB$	
` !$
	0B$
`(!$
P@$	
@ !$
ON4BFI
ON4FFI
ON4BFI
ON4FFI
EP4BPS
EP4FPS
8$B!
 $cet
 $cet
 $cet
 $cet
 $cet
 $cet
 $cet
 $cet
 $Bet
 $Bet
 $cet
 $Bet
 $Bet
8$BV<
8$BX4
8$BD$
8$BY
` !$
 $cEX
 $cG
 $cN
 $cQ
 $cC
 $cL\
 $cS`
 $cU
 $cX0
 $cJ
 $cL\
 $cS`
 $cL\
 $cS`
 $cU
 $cX0
 $cZ
 $c]
 $c_
 $cb
@(!'
0$BU
0$BXx
DpV 
` !$
P@$	
0$BU
0$BU
` !$
@ !0
@0!'
@ !0
@ !0
@(!$
P@$	
P@$	
@ !$
0$BXx
@ !$
0$BXx
 $D4
 $D5
 $E4d
 $D4
 $D5
 $B4
 $B3
 $DnP
 $Dnt
 $cm
 $Dn
 $Dn,
 $cm
 $Dm
 $Dm
 $Bm
 $B3
 $DnP
 $Dnt
 $cm
 $Dm
 $Dm
 $cm
 $B3|
 $B34
@(!$
@ !$
@ !$
@ !$
@ !$
@ !$
@ !$
@(!$
@(!$
4pC 
(pW 
@0!$
<$B,
<$B"
<$B$D
<$B-
<$c4|
<$B4T
@(!$
!rQ 
<$c4|
<$B4T
<$B4T
<$B4T
` !$
@(!$
` !$
@(!$
<$BHT
<$BIL
` !$
<$BG
<$BN
<$BG
<$BN
<$BIL
<$Bh
<$Bd
<$Bi
<$Bh
<$Bi
<$Bi
<$Bh
<$Bm
<$Bo(
<$Bl
<$Bl
<$B	p
<$Bfx
<$Bl
<$Bl
<$B	p
<$Bg
` !$
<$Bm
<$Bv
<$Bfx
<$Bo(
<$B	p
<$Bo(
<$Bg
<$Bh@
<$Bo(
<$Bo(
<$Bfx
<$Bo(
<$Bfx
<$Bo(
<$Bg
<$B	p
<$Bm
<$Bg
<$Bh@
<$Bo(
<$Bo(
<$Bfx
<$Bo(
<$Bfx
<$Bo(
<$Bg
<$Bnp
<$Bg
<$Bo(
<$Bgp
<$Be
@0!$
@P!q
@P!q
` !$
 $Bn
 $Bn
 $Bn
 $Bn
UB4BI#
UB4BI#
@(!$
UB4cI#
@(!$
UB4BI!
UB4BI!
@(!$
UB4cI!
@(!$
<$Be(
<$Be(
<$Be(
@ !$
@ !$
@ !$
@ !$
<$Bf
@ !$
<$Bf
<$Bf
<$Bf
@ !$
@0!$
<$Be
<$Be
@ !$
@ !$
(0B@
`(!<
`(!<
@$B 
@$B 
@$B 
@$B 
@$B 
@$B 
@$B 
@$B 
@0!$
@$B!
4B1%
@0!$
@$B#p
@0!$
@$B#p
@0!$
@$B#p
@0!$
@$B#p
@0!$
@$B#p
@0!$
@$B!
@0!$
@$B#p
@$B%
@$B-
@$B-
 0B@
@$B'
,$Bx
0$Bx
@$B*
@$B4
@$c1
@$c.
I4B$
.4cE
.4cE
 $Bn
 $Bn
.4cE
.4cE
I4B$
@$BI
@$BH(
@(!$
@(!$
@(!$
@$BS
@$BR
@$BR
@$BR,
@$BR
@$BQ
@$BR
@$BR
@$BR
@$BR,
@$BR
@$BR
UU4BUV
@$BN8
@ !$
@ !$
@$BaH
@$BR,
` !$
@$BQ
@$BR
@$BR,
@ !$
@$BQ
@$Bb
@$BR
@$BR
@$B[
@ !$
@$B[
@$BR,
@$BR
@$BR
@$BR,
@$BR
@$BR
@$Bgp
@$B[
@ !$
@$B[
@$Bd
` !$
@$BQ
@$BV
@$Bs<
@$BQ
@$Bs<
@$Bs<
@$BQ
@$Bs<
@$BQ
@$BN
@$BQ
@$BPt
@$BT
@$BQ
@$BOH
@$BO
@$BT
@(!$
@(!$
` !$
@$BQ
@$Bs
@$Bn\
@$Bgp
@$Bjx
@$BWX
@$B~
 $Bn
@ !$
@ !$
@ !$
@ !$
@ !$
@ !$
.4cE
.4cE
I4B$
 $Do
 $Do 
 $Do
@(!$
@(!$
@(!$
@(!$
@(!$
@ !<
@ !$
@ !$
@0!$
TpC 
@(!$
@0!$
D$B+
D$e4
D$B.
 $DoH
 $do0
D$B4
D$B9
D$B9
4pC0
D$c:0
D$c;
@(!$
!rQ 
D$B;
@(!$
@ !$
D$BN
D$BQ
D$Bm
@ !$
@(!$
@(!$
@(!$
@(!$
D$B~|
D$B~|
D$B~|
D$Bj@
D$Bh
D$Bk
D$Bl
D$Bk
D$Bj@
D$Bh
D$B}
D$Bk
D$Bl
D$Bk
D$B}
D$Bj
 $B&
D$Bj
D$Bj
D$Bk0
D$Bl
D$BmL
D$Bl
D$Bk0
D$Bih
@ !$
D$Bl
@ !$
D$Bl
H$B	,
H$B	,
D$Bl
D$Bl
H$B	,
H$B"
H$B	,
H$B"
H$B+
H$B+
H$B"
H$B7
@ !$
H$B9X
H$BB
H$BI
H$BL`
H$BIH
H$BN`
H$BK8
H$BR
H$BV
H$BV
H$BV
H$BV
@(!$
@(!$
` !$
` !$
H$BV
H$BV
H$BV
H$B_
H$BaT
H$B_
H$BaT
H$Bb
H$BaT
H$BV
H$B_
H$BaT
H$Bf
H$BaT
H$BaT
H$Bd
H$Bn
H$Bu
H$BvT
H$Bu
H$Bs
H$Bu
H$Bs
H$Bu
H$B~
H$B~0
 $B `
H$B}
H$BIl
H$BIl
H$BIl
 $B P
@ !$
@ !$
@ !$
	i@1
Y@1N
@(!$
@(!$
 $B&
 $B&
L$B 
L$B 
L$B L
L$B! 
L$B!
,B	@
L$B"
,B	@
L$B"
L$B"
L$B"
L$B"
L$B"x
L$B"
L$B"x
L$B"
L$B"x
L$B"
L$B"x
L$B4D
L$B4
` !$
`(!$
@(!$
b !<
@(!$
@(!$
@(!$
@(!$
L$BP
 @$B (
 @$c (
`(!$
L$BP|
@(!$
@(!$
@(!$
@(!$
b4BM
@ !$
4BSc
b4BM
4BSc
4BSc
@(!$
@(!$
@(!$
@ !$
@(!$
@(!$
@(!$
@ !$
@ !$
@(!$
@ !$
@(!$
@(!$
@(!$
@(!$
@(!$
@ !$
@ !$
Do`<
b4BM
Bo`,B
@(!$
@ !<
H8#$
H +T
H +T
dX#%
*** reset failed ***
*** failed ***
DRAM:  
baudrate
NAND:  
ipaddr
loadaddr
bootfile
Net:   
### ERROR ### Please RESET the board ###
bootargs
memsize
0x%08X
initrd_start
0x%X
initrd_size
flash_start
flash_size
ethaddr
eth1addr
Starting kernel ...
## Starting application at 0x%08lX ...
## Application terminated, rc = 0x%lX
start application at address 'addr'
addr [arg ...]
    - start application at address 'addr'
      passing 'arg' as arguments
reset
Perform RESET of the CPU
verify
ERROR: can't get kernel image!
ERROR: unknown image format type!
Could not find kernel entry point!
Ramdisk image is corrupt or invalid
   XIP %s ... 
   Loading %s ... 
   Uncompressing %s ... 
GUNZIP: uncompress, out-of-mem or overwrite error - must RESET board to recover
LZO: uncompress or overwrite error %d - must RESET board to recover
Unimplemented compression type %d
autostart
filesize
start
loados
cmdline
prep
Trying to execute a command out of order
cmdline subcommand not supported
bdt subcommand not supported
prep subcommand not supported
WARNING: legacy format multi component image overwritten
ERROR: new format image overwritten - must RESET the board to recover
ERROR: booting os '%s' (%d) is not supported
Automatic boot of image at addr 0x%08lX ...
Bad Magic Number
Bad Header Checksum
   Verifying Checksum ... 
Bad Data CRC
Unsupported Architecture 0x%x
## Booting kernel from Legacy Image at %08lx ...
Wrong Image Type for %s command
Wrong Image Format for %s command
bootm
boot application image from memory
[addr [arg ...]]
    - boot application image stored in memory
	passing arguments 'arg ...'; when booting a Linux kernel,
	'arg' can be the address of an initrd image
Sub-commands to do part of the bootm sequence.  The sub-commands must be
issued in the order below (it's ok to not issue all sub-commands):
	start [addr [arg ...]]
	loados  - load OS image
	cmdline - OS specific command line processing/setup
	bdt     - OS specific bd_t processing
	prep    - OS specific prep before relocation or go
	go      - start OS
bootcmd
boot
boot default, i.e., run 'bootcmd'
bootd
## Checking Image at %08lx ...
   Legacy image found
   Bad Magic Number
   Bad Header Checksum
   Bad Data CRC
Unknown image format!
iminfo
print header information for application image
addr [addr ...]
    - print header information for application image starting at
      address 'addr' in memory; this includes verification of the
      image contents (magic number, header and payload checksums)
bootargs
## Transferring control to NetBSD stage-2 loader (at address %08lx) ...
## Transferring control to RTEMS (at address %08lx) ...
sb3: top available addr 0x%08x, ram available = 0x%x 
__FoRCe ReCoVeRy NoRMaL__
__FoRCe ReCoVeRy ReSCue__
__FoRCe ReCoVeRy NeTWoRK_
__cleared by sb3__
sb3_load_ubivol: max_load_size=%d
part_main
sb3: no ubi volume %s
sb3: ubi volume %s is empty
sb3: legacy image %s is corrupted (length is %d instead of %d)
sb3: payload %s cannot be booted from %s
sb3: preboot commands size too big (%d)
sb3: malloc failed
sb3: No pre-boot commands
sb3: going to execute following pre-boot commands: %s
sb3: a pre-boot command went wrong
sb3: pre-boot commands done !
 rootfs_offset=0x%08x rootfs_size=0x%08x
sb3: No kernel args found in image %s
mtdparts
part_boot
 secure
%s ubi.mtd=%s part_main=%s part_boot=%s image_ubivol=%s%s board_type=%08x
sb3: cannot allocate kernel_args of length %d
%s %s
sb3: setting kernel args
bootargs
sb3: %s( %s )
sb3: image %s is too small ( == %d bytes)
sb3: image %s is too big (image_size=%d >= max_load_size=%d bytes)
sb3: image %s is too big and cannot be moved
sb3: image %s moved to %p-%p
sb3: image %s has crypt-dsa format
sb3: image %s has gsdf format
sb3: image %s has unknown format
sb3: image %s has bad signature
sb3: image %s signature OK
bootm
%s %s 
sb3: %s()
ethaddr
4C:42:50:72:6F:33
sb3: action: %x
operational
rescue
sb3: please power off the gateway
sb3: unexpected action %d
secure boot
usage: dfa_set string (20 characters max)
error: DFA is too long  (max is %d characters)
error: DFA can only be set one time
 (set value is: %s)
DFA is not yet set
usage: cie_set string (20 characters max)
error: CIE is too long  (max is %d characters)
error: DFA must be set before CIE
error: CIE can only be set one time
CIE is not yet set
usage: flag_set flagNumber (from 1 to 8)
error: DFA and CIE must be set before flags
setting flag %d
error: all flags before flag %d must already be set
error: flag %d is already set
%d  OFF
%d  ON
dfa_set
sets the DFA parameter
displays the DFA parameter
cie_set
sets the CIE parameter
displays the CIE parameter
flag_set
sets one factory flag
flag
displays the factory flags
usage: secure_set on
setting bootloader in secure mode
secure_set
sets the bootloader in secure mode
help
print command description/usage
	- print brief description of all commands
help command ...
	- print detailed usage of 'command'
alias for 'help'
Unknown operator '%s'
Invalid data width specifier
itest
return true/false on integer compare
[.b, .w, .l, .s] [*]value1 <op> [*]value2
onenand
nand
invalid partition number %d for device %s%d (%s)
bootfile
uImage
JFFS2
### %s loading '%s' to 0x%lx
### %s load complete: %d bytes loaded to 0x%lx
filesize
### %s LOAD ERROR<%x> for %s!
### filesystem type is %s
fsload
load binary file from a filesystem image
[ off ] [ filename ]
    - load binary file from flash bank
      with offset 'off'
list files in a directory (default /)
[ directory ]
fsinfo
print information about filesystems
word at 0x%08lx (0x%08lx) != word at 0x%08lx (0x%08lx)
halfword at 0x%08lx (0x%04x) != halfword at 0x%08lx (0x%04x)
byte at 0x%08lx (0x%02x) != byte at 0x%08lx (0x%02x)
halfword
byte
word
Total of %ld %s%s were the same
Zero length ???
Base Address: 0x%08lx
Tested %d iteration(s) with %lu errors.
Pattern %08lX  Writing...%12s
Reading...
Mem error @ 0x%08X: found %08lX, expected %08lX
%08lx:
 %08x
 %04x
 %02x
CRC32 for %08lx ... %08lx ==> %08lx
memory display
[.b, .w, .l] address [# of objects]
memory modify (auto-incrementing address)
[.b, .w, .l] address
memory modify (constant address)
memory write (fill)
[.b, .w, .l] address value [count]
memory copy
[.b, .w, .l] source target count
memory compare
[.b, .w, .l] addr1 addr2 count
crc32
checksum calculation
address count [addr]
    - compute CRC32 checksum [save at addr]
base
print or set address offset
    - print address offset for memory commands
base off
    - set address offset for memory commands to 'off'
loop
infinite loop on address range
[.b, .w, .l] address number_of_objects
mtest
simple RAM read/write test
[start [end [pattern [iterations]]]]
sleep
delay execution for some time
    - delay execution for N seconds (N is _decimal_ !!!)
nand0=nand
mtdparts=nand:768k(bcm),125184k(partAll),5120k(data)
mtddevnum
mtddevname
onenand
nand
%s%d,%d
partition
%s%d
Device %s not found!
%s%d: partition (%s) start offsetalignment incorrect
%s%d: partition (%s) size alignment incorrect
%s%d: partition (%s) start offset alignment incorrect
%s: offset %08x beyond flash size %08x
%s%d: partition (%s) size too big
%s: partitioning exceeds flash size
current partition deleted, resetting current to 0
cannot add second partition at offset 0
partition size too small (%lx)
no closing ) found in partition name
empty partition name
no partitions allowed after a fill-up partition
unexpected character '%c' at the end of partition
out of memory
0x%08lx@0x%08lx
no <mtd-id> identifier
invalid mtd device '%.*s'
no partitions for device %s%d (%s)
unexpected character '%c' at the end of device
incorrect device type in %s
incorrect device number in %s
mtdparts=
mtdparts
device %s%d <%s>, # parts = %d
 #: name		size		offset		mask_flags
%2d: %-20s0x%08x	0x%08x	%d
no partitions defined
active partition: %s%d,%d - (%s) 0x%08x @ 0x%08x
could not get current partition info
defaults:
none
mtdids  : %s
mtdparts: 
no partition number specified
unexpected trailing character '%c'
no such device %s%d
no such partition
generated mtdparts too long, reseting to null
partition %s not found
could not initialise device list
mtdparts variable doesn't start with 'mtdparts='
device %s%d redefined, please correct mtdparts variable
mtdids: incorrect <dev-num>
mtdids: no <mtd-id> identifier
device id %s%d redefined, please correct mtdids variable
mtdids
mtdids not defined, no default present
mtdids too long (> %d)
mtdparts variable not set, see 'help mtdparts'
mtdparts too long (> %d)
mtdparts_init: no valid partitions
invalid partition number %d for device %s%d (%s)
no partition id specified
partition changed to %s%d,%d
default
delall
no such device %s defined in mtdids variable
too long partition description
%s:%s(%s)%s
chpart
change active partition
part-id
    - change active partition (e.g. part-id = nand0,1)
define flash/nand partitions
    - list partition table
mtdparts delall
    - delete all partitions
mtdparts del part-id
    - delete partition (e.g. part-id = nand0,1)
mtdparts add <mtd-dev> <size>[@<offset>] [<name>] [ro]
    - add partition
mtdparts default
    - reset partition table to defaults
-----
this command uses three environment variables:
'partition' - keeps current partition identifier
partition  := <part-id>
<part-id>  := <dev-id>,part_num
'mtdids' - linux kernel mtd device id <-> u-boot device id mapping
mtdids=<idmap>[,<idmap>,...]
<idmap>    := <dev-id>=<mtd-id>
<dev-id>   := 'nand'|'nor'|'onenand'<dev-num>
<dev-num>  := mtd device number, 0...
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
'mtdparts' - partition list
mtdparts=mtdparts=<mtd-def>[;<mtd-def>...]
<mtd-def>  := <mtd-id>:<part-def>[,<part-def>...]
<mtd-id>   := unique device tag used by linux kernel to find mtd device (mtd->name)
<part-def> := <size>[@<offset>][<name>][<ro-flag>]
<size>     := standard linux memsize OR '-' to denote all remaining space
<offset>   := partition start offset within the device
<name>     := '(' NAME ')'
<ro-flag>  := when set to 'ro' makes partition read-only (not used, passed to kernel)
No memory for page buffer
Error (%d) reading page %08lx
Page %08lx dump:
	%02x %02x %02x %02x %02x %02x %02x %02x  %02x %02x %02x %02x %02x %02x %02x %02x
OOB:
	%02x %02x %02x %02x %02x %02x %02x %02x
No such device
Device %d: %s
... is now current device
not a NAND device
Offset exceeds device limit
'%s' is not a number
Size exceeds partition or device limit
device %d 
whole chip
offset 0x%llx, size 0x%llx
Device %d: 
%dx 
%s, sector size %u KiB
  Page size  %8d b
  OOB size   %8d b
  Erase size %8d b
nand_writesize
nand_oobsize
nand_erasesize
quiet
dump
info
device
no devices available
no devices available
Device %d bad blocks:
  %08llx
erase
scrub
clean
Warning: scrub option will erase all factory set bad blocks!
         There is no reliable way to recover them.
         Use this command only for testing purposes if you
         are sure of what you are doing!
Really scrub this NAND flash? <y/N>
.spread
.part
.chip
NAND %s: 
scrub aborted
ERROR
.oob
read
write
.jffs2
.raw
Unknown nand command suffix '%s'.
written
 %zu bytes %s: %s
markbad
block 0x%08lx NOT marked as bad! ERROR %d
block 0x%08lx successfully marked as bad
biterr
rnderrs
Device %d bad blocks table:
trace
nand trace %s
nand
NAND sub-system
info - show available NAND devices
nand device [dev] - show or set current device
nand read - addr off|partition size
nand write - addr off|partition size
    read/write 'size' bytes starting at offset 'off'
    to/from memory address 'addr', skipping bad blocks.
nand read.raw - addr off|partition
nand write.raw - addr off|partition
    Use read.raw/write.raw to avoid ECC and access the page as-is.
nand erase[.spread] [clean] off size - erase 'size' bytes from offset 'off'
    With '.spread', erase enough for given file size, otherwise,
    'size' includes skipped bad blocks.
nand erase.part [clean] partition - erase entire mtd partition'
nand erase.chip [clean] - erase entire chip'
nand bad - show bad blocks
nand dump[.oob] off - dump page
nand scrub [-y] off size | scrub.part partition | scrub.chip
    really clean NAND erasing bad blocks (UNSAFE)
nand markbad off [...] - mark bad block(s) at offset (UNSAFE)
nand biterr off - make a bit error at offset (UNSAFE)nand rnderrs n seed- make n random bit errors (UNSAFE)
nand bbt - show bad blocks table
nand trace [on|off] - trace NAND access 
Unknown nand load suffix '%s'
Loading from %s, offset 0x%lx
** Read error
** Unknown image type
Not a NAND device
bootdevice
** No boot device **
** Device %d not available
nboot
boot from NAND device
[partition] | [[[loadAddr] dev] offset]
bootp
boot image via network using BOOTP/TFTP protocol
[loadAddress] [[hostIPaddr:]bootfilename]
tftpboot
boot image via network using TFTP protocol
dhcp
boot image via network using DHCP/TFTP protocol
gatewayip
netmask
hostname
rootpath
ipaddr
serverip
dnsip
domain
loadaddr
ping failed; host %s is not alive
host %s is alive
ping
send ICMP ECHO_REQUEST to network host
pingAddress
%s=%s
Environment size: %d/%ld bytes
## Error: "%s" not defined
## Error: illegal character '=' in variable name"%s"
stdin
stdout
stderr
Can't delete "%s"
serial#
ethaddr
00:01:02:03:04:05
Can't overwrite "%s"
baudrate
## Baudrate %d bps not supported
## Switch baudrate to %d bps andpress ENTER ...
## Can't malloc %d bytes
## Error inserting "%s" variable, errno=%d
ipaddr
loadaddr
bootfile
setenv
edit: 
env_buf [%d bytes] too small for value of "%s"
Saving Environment to %s...
saveenv
save environment variables to persistent storage
## Resetting to default environment
Not implemented yet
ERROR: Cannot export environment: errno = %d
at %s:%d/%s()
cmd_nvedit.c
filesize
## %s: only one of "-b", "-c" or "-t" allowed
## Warning: defaulting to text format
## Warning: Input data exceeds %d bytes - truncated
## Info: input data size = %zu = 0x%zX
## Error: bad CRC, import failed
ERROR: Environment import failed: errno = %d
at %s:%d/%s()
default
delete
edit
export
import
print
save
environment handling commands
default -f - reset default environment
env edit name - edit environment variable
env export [-t | -b | -c] [-s size] addr [var ...] - export environment
env import [-d] [-t | -b | -c] addr [size] - import environment
env print [name ...] - print environment
env run var [...] - run commands in an environment variable
env save - save environment
env set [-f] name [arg ...]
editenv
edit environment variable
name
    - edit environment variable 'name'
printenv
print environment variables
    - print values of all environment variables
printenv name ...
    - print value of environment variable 'name'
set environment variables
name value ...
    - set environment variable 'name' to 'value ...'
setenv name
    - delete environment variable 'name'
run commands in an environment variable
var [...]
    - run the commands in the environment variable(s) 'var'
verify
Bad magic number
Bad header crc
Bad data crc
Bad image type
Empty Script
Wrong image format for "source" command
## Executing script at %08lx
source
run script from memory
[addr]
	- run script starting at addr
	- A valid image header must be present
UBI: volume information dump:
UBI: vol_id          %d
UBI: reserved_pebs   %d
UBI: alignment       %d
UBI: data_pad        %d
UBI: vol_type        %d
UBI: name_len        %d
UBI: usable_leb_size %d
UBI: used_ebs        %d
UBI: used_bytes      %lld
UBI: last_eb_bytes   %d
UBI: corrupted       %d
UBI: upd_marker      %d
UBI: name            %s
UBI: the 1st 5 characters of the name: %c%c%c%c%c
UBI: MTD device name:            "%s"
UBI: MTD device size:            %llu MiB
UBI: physical eraseblock size:   %d bytes (%d KiB)
UBI: logical eraseblock size:    %d bytes
UBI: number of good PEBs:        %d
UBI: number of bad PEBs:         %d
UBI: smallest flash I/O unit:    %d
UBI: VID header offset:          %d (aligned %d)
UBI: data offset:                %d
UBI: max. allowed volumes:       %d
UBI: wear-leveling threshold:    %d
UBI: number of internal volumes: %d
UBI: number of user volumes:     %d
UBI: available PEBs:             %d
UBI: total number of reserved PEBs: %d
UBI: number of PEBs reserved for bad PEB handling: %d
UBI: max/mean erase counter: %d/%d
No space left in UBI device!
Name too long!
verify_mkvol_req failed %d
dynamic
static
Creating %s volume %s of size %d
Volume %s not found!
Remove UBI volume %s (id %d)
It's read-only mode
Error changing Vol tabel record err=%x
UBI: reserve more %d PEBs
UBI error: %s: cannot remove volume %s, error %d
size > volume size! Aborting!
Cannot start volume update
Couldnt or partially wrote data
UBI warning: %s: volume %d on UBI device %d is corrupted
%d bytes written to volume %s
Read %d bytes from volume %s to %p
updating
damaged volume, update marker is set
read from corrupted volume %d
NO MEM
read err %x
mtd=%d
mtd=%d,%s
Error initializing mtdparts!
part
Error, no UBI device/partition selected!
Device %d: %s, partition %s
Partition %s not found!
onenand
nand
%s%d
Partition %s not found on device %s!
UBI init error %d
info
create
Incorrect type
No size specified -> Using max size (%u)
remove
write
Please see usage
read
ubi commands
part [part] [offset]
 - Show or set current partition (with optional VID header offset)
ubi info [l[ayout]] - Display volume and ubi layout information
ubi create[vol] volume [size] [type] - create volume name with size
ubi write[vol] address volume size - Write volume from address with size
ubi read[vol] address volume [size] - Read volume to address with size
ubi remove[vol] volume - Remove volume
[Legends]
 volume: character name
 size: specified in bytes
 type: s[tatic] or d[ynamic] (default=dynamic)
Unmounting UBIFS volume %s!
No UBIFS volume mounted!
UBIFS not mounted, use ubifs mount to mount volume first!
%s not found!
ubifsmount
mount UBIFS volume
<volume-name>
    - mount 'volume-name' volume
ubifsumount
unmount UBIFS volume
    - unmount current volume
ubifsls
list files in a directory
[directory]
    - list files in a 'directory' (default '/')
ubifsload
load file from an UBIFS filesystem
<addr> <filename> [bytes]
    - load file 'filename' to address 'addr'
mips-openwrt-linux-uclibc-gcc (GCC) 4.4.2
GNU ld (GNU Binutils) 2.20.1
version
print monitor, compiler and linker version
%-*s- %s
Unknown command '%s' - try 'help' without arguments for list of all known commands
%s - %s
Usage:
- No additional help available.
*** Warning - %s, using default environment
Using default environment
ERROR: Environment import failed: errno = %d
at %s:%d/%s()
env_common.c
!bad CRC
ERROR: Cannot import environment: errno = %d
at %s:%d/%s()
!import failed
NAND
part_boot
bootenv
ERROR: Cannot export environment: errno = %d
at %s:%d/%s()
env_nand.c
!readenv() failed
Invalid ARCH
alpha
Alpha
Intel x86
ia64
IA64
m68k
M68K
microblaze
MicroBlaze
mips
MIPS
mips64
MIPS 64 Bit
nios2
NIOS II
powerpc
PowerPC
s390
IBM S390
SuperH
sparc
SPARC
sparc64
SPARC 64 Bit
blackfin
Blackfin
avr32
AVR32
nds32
NDS32
Invalid OS
linux
Linux
netbsd
NetBSD
Enea OSE
rtems
RTEMS
u-boot
U-Boot
aisimage
Davinci AIS image
filesystem
Filesystem Image
firmware
Firmware
flat_dt
Flat Device Tree
kernel
Kernel Image
kernel_noload
Kernel Image (no loading done)
kwbimage
Kirkwood Boot Image
imximage
Freescale i.MX Boot Image
Invalid Image
multi
Multi-File Image
omapimage
TI OMAP SPL With GP CH
ramdisk
RAMDisk Image
script
Script
standalone
Standalone Program
ublimage
Davinci UBL image
none
uncompressed
bzip2
bzip2 compressed
gzip
gzip compressed
lzma
lzma compressed
lzo compressed
%s %s %s (%s)
%sImage Name:   %.*s
%sCreated:      
%sImage Type:   
%sData Size:    
%sLoad Address: %08x
%sEntry Point:  %08x
%sContents:
%s   Image %d: 
%s    Offset = 0x%08lx
Bad Magic Number
Bad Header Checksum
   Verifying Checksum ... 
Bad Data CRC
No Linux %s Ramdisk Image
bootm_low
bootm_size
bootm_mapsize
%d Bytes = 
%4d-%02d-%02d  %2d:%02d:%02d UTC
Unknown OS
Unknown Architecture
Unknown Image
Unknown Compression
Image
Compression
## Loading init Ramdisk from Legacy Image at %08lx ...
Wrong Ramdisk Image Format
## Loading init Ramdisk from multi component Legacy Image at %08lx ...
%02x 
GSDF 10
gsdf ident string OK
gsdf size OK
gsdf auth_hash OK
gsdf head_hash OK
gsdf data_hash OK
found a root CA certificate in section %d
found a secondary certificate in section %d
error: Cannot parse certif in section %d  error %d
error: Wrong number of certificates
    expected 1 root        (actual %d)
    expected 0 or 1 second (actual %d)
error: improperly chained certificates  (flags %02x)
certificate chain OK
root certificate OK  (sagemcom caCert)
root certificate OK  (orange CA_FT_PKI_FW)
error: root certificate not authorized
    unknown hash: 
%02x
not a livebox. no subject name verification
      
error: x509parse_cert_info returned %d
CN=Orange Devices Sign Firmware CA
CN=FW Sign Livebox Pro V3
CN=FW Sign Livebox 3 R
CN=FW Sign Livebox 2.8
not an Orange certificate chain. no subject name verification
certificate subject name is OK for a Livebox Pro V3
certificate subject name is OK for a Livebox 3 Residential
certificate subject name is BAD for this machine
error: Public key has wrong length (%d bits)
signature OK
unknown
operational firmware
rescue firmware
permanent parameters
bootloader
update firmware
refurbish firmware
test firmware
root security parameters
attribute certificate
root cert
second cert
attrcert/rsps
perm params
prim bl args
sec bl args
u-boot args
prim bl img
sec bl img
u-boot img
kernel args
kernel img
squashfs
error: payload "%s"   
duplicate "%s" section
"%s" section is forbidden
"%s" section is missing
section list OK
Header information:
    size             %d
    payload type     %s
    version count    %d
    signing time     %04d:%02d:%02d  %02d:%02d:%02d
    name             %s
Sections content:
 %2d  %8d  %13s  
error: buffer content is not valid GSDF data  error %d
error: Could not parse certificates  error %d
error: gsdfVerifyRootTrust  error %d
error: gsdfVerifySubjectName  error %d
error: gsdfVerifySignature  error %d
error: gsdfVerifySectionList  error %d
error: buffer content has invalid hash  error %d
Hit any key to stop autoboot: %2d 
%2d 
bootdelay
bootcmd
<INTERRUPT>
%.*s
impossible condition #876
** Too many args (max. %d) **
## Command too long!
Unknown command '%s' - try 'help'
'bootd' recursion detected
## Error: "%s" not defined
stdin
stdout
stderr
serial
Cksum
xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries
Can't access file
Sorry, zModem not available yet
Timed out
End of file
Cancelled
Invalid framing
CRC/checksum error
Block sequence error
Unknown error
0!0	
U-Boot BUG at %s:%d!
mtdcore.c
Removing MTD device #%d (%s) with use count %d
memory allocation error while creating partitions for "%s"
Moving partition %d: 0x%012llx -> 0x%012llx
0x%012llx-0x%012llx : "%s"
mtd: partition "%s" is out of reach -- disabled
mtd: partition "%s" extends beyond the end of device "%s" -- size truncated to %#llx
BUG: failure at %s:%d/%s()!
mtdpart.c
BUG!
mtd: partition "%s" doesn't start on an erase block boundary -- force read-only
mtd: partition "%s" doesn't end on an erase block -- force read-only
Creating %d MTD partitions on "%s":
nand%d
%u MiB
nand_bbt: Error reading bad block table
nand_bbt: ECC error while reading bad block table
nand_read_bbt: Reserved block at 0x%012llx
nand_read_bbt: Bad block at 0x%012llx
Bad block table at page %d, version 0x%02X
create_bbt(): chipnr (%d) > available chips (%d)
Bad block table not found for chip %d
Bad block table found at page %d, version 0x%02X
No space left to write bad block table
nand_bbt: Error reading block for writing the bad block table
nand_bbt: ECC error while reading block for writing bad block table
Bad block table written to 0x%012llx, version 0x%02X
nand_bbt: Error while writing bad block table %d
nand_scan_bbt: Out of memory
nand_bbt: Can't scan flash and build the RAM-based BBT
nand_bbt: Out of memory
nand_update_bbt: Out of memory
NAND 16MiB 1,8V 8-bit
NAND 16MiB 3,3V 8-bit
NAND 16MiB 1,8V 16-bit
NAND 16MiB 3,3V 16-bit
NAND 32MiB 1,8V 8-bit
NAND 32MiB 3,3V 8-bit
NAND 32MiB 1,8V 16-bit
NAND 32MiB 3,3V 16-bit
NAND 64MiB 1,8V 8-bit
NAND 64MiB 3,3V 8-bit
NAND 64MiB 1,8V 16-bit
NAND 64MiB 3,3V 16-bit
NAND 128MiB 1,8V 8-bit
NAND 128MiB 3,3V 8-bit
NAND 128MiB 1,8V 16-bit
NAND 128MiB 3,3V 16-bit
NAND 256MiB 3,3V 8-bit
NAND 256MiB 1,8V 8-bit
NAND 256MiB 1,8V 16-bit
NAND 256MiB 3,3V 16-bit
NAND 512MiB 1,8V 8-bit
NAND 512MiB 3,3V 8-bit
NAND 512MiB 1,8V 16-bit
NAND 512MiB 3,3V 16-bit
NAND 1GiB 1,8V 8-bit
NAND 1GiB 3,3V 8-bit
NAND 1GiB 1,8V 16-bit
NAND 1GiB 3,3V 16-bit
NAND 2GiB 1,8V 8-bit
NAND 2GiB 3,3V 8-bit
NAND 2GiB 1,8V 16-bit
NAND 2GiB 3,3V 16-bit
AND 128MiB 3,3V 8-bit
Toshiba
Samsung
Fujitsu
National
Renesas
ST Micro
Hynix
Micron
Unknown
Attempt to erase non page aligned data
Skipping bad block at  0x%08llx                                          
%s: MTD get bad block failed: %d
%s: MTD Erase failure: %d
%s: MTD writeoob failure: %d
Erasing at 0x%llx -- %3d%% complete.
 Cleanmarker written at 0x%llx.
Attempt to write non page aligned data
Attempt to write outside the flash area
NAND write to offset %llx failed %d
Skip bad block 0x%08llx
Attempt to read non page aligned data
Attempt to read outside the flash area
NAND read from offset %llx failed %d
Skipping bad block 0x%08llx
BUG: failure at %s:%d/%s()!
nand_base.c
BUG!
Timeout!
nand_do_write_ops: Device is write protected
nand_erase: attempt to erase a bad block at page 0x%08x
%s: second ID read did not match %02x,%02x against %02x,%02x
%s: unknown NAND device: Manufacturer ID: 0x%02x, Chip ID: 0x%02x
NAND device: Manufacturer ID: 0x%02x, Chip ID: 0x%02x (%s %s)
NAND bus width %d instead %d bit
No NAND device found!!!
No oob scheme defined for oobsize %d
No ECC functions supplied, Hardware ECC not possible
%d byte HW ECC not possible on %d byte page size, fallback to SW ECC
NAND_ECC_NONE selected by board driver. This is not recommended !!
Invalid NAND_ECC_MODE %d
Invalid ecc parameters
Status wait timeout: nandsts=0x%8.8lx mask=0x%8.8lx, count=%lu
Correctable ECC Error detected: addr=0x%8.8lx, intrCtrl=0x%08X, accessCtrl=0x%08X
Error writing to spare area, sts=0x%8.8lx
Uncorrectable ECC Error: addr=0x%8.8lx
nandflash_read_page: cleanmarker not found at 0x%8.8lx
>> nand_mark_bad_blk - addr=0x%8.8lx, block=0x%8.8lx
Error erasing block 0x%8.8lx, sts=0x%8.8lx
%s(start_addr=%lx, %d)=%d, forced 1
Error writing to block, sts=0x%8.8lx
nandflash_write_page: cleanmarker not found at 0x%8.8lx
>> nand_initialize_spare_area - entry
Initialization error erasing flash block, blk=%lu
Error writing clean marker, blk=%d
Error erasing flash block, blk=%d
>> nand_flash_read_buf - 1 blk=0x%8.8x, offset=%d, len=%d
>> nand_flash_read_buf - 2 blk=0x%8.8x, len=%d
>> nand_flash_read_buf - ret=%d
Disable NAND fast program read and partial page enablefor MLC part.
Changing ECC to BCH-4 from Hamming for MLC part
NAND Access Control register = 0x%8.8lx
>> nand_read_cfg - layout_parms=0x%8.8lx
No valid spare layout for level=%lu, spare size=%lu, page size=%lu
>> nand_read_cfg - size=%luMB, block=%luKB, page=%luB, spare=%lu
Parallel flash device
Serial flash device
HS Serial flash device
NAND flash device
: name %s, id 0x%4.4x
 block %dKB
 size %dKB
 id %4.4x is not supported.
>> nand_flash_init - entry
<not identified>
BCM Flash API. Flash device is not found.
bcm63xxx_nand_write_buf =>TODO<= buf %p  len %x
bcm63xxx_nand_write_page_lowlevel  mtd %p  chip %p  buf %p
%s (command=%x, column=%x, page_addr=%x =>TODO<=
bcm63xxx_nand_write_oob  mtd %p  chip %p  page %d
%s =>TODO<=
pageAddr out of range (must be < 0x%08lx)
bitOffset out of range (must be < %lx)
generating error
    page 0x%08x
    clearing bit 0x%x
  (subpage %d data)
  (oob range)
create %d random bit errors inside the nand
bcm63xxx nand initialization
Warn : Nand chip protected from 0 to %x
Samsung K9F1G08U0A
ST ST_NAND512W3A
ST ST_NAND256W3A
Hynix HY27UF081G2A
Samsung K9F2G08U0A
Samsung K9F8G08U0M
Hynix HY27UF082G2A
Hynix HY27U4G8F2D
SPANSION S30ML512P_08
SPANSION S30ML512P_16
SPANSION S30ML256P_08
SPANSION S30ML256P_16
SPANSION S30ML128P_08
SPANSION S30ML128P_16
SPANSION_S30ML01GP_08
SPANSION_S30ML01GP_16
SPANSION_S30ML02GP_08
SPANSION_S30ML02GP_16
SPANSION_S30ML04GP_08
SPANSION_S30ML04GP_16
ST NAND128W3A
ST NAND01GW3B2B
ST NAND02GW3B2C
ST NAND04GW3B2B
ST NAND08GW3B2A
Samsung K9LBG08U0M
Samsung K9LBG08UD
Samsung K9GAG08U0D
Samsung K9GAG08U0E
HYNIX_HY27UT088G2A
HYNIX_HY27UAG8T2M
TOSHIBA TC58NVG0S3ETA00
TOSHIBA TC58NVG1S3ETAI5
TOSHIBA TC58NVG3S0ETA00
MICRON MT29F1G08ABA
MICRON MT29F2G08ABA
MICRON MT29F4G08ABA
MICRON MT29F8G08ABA
ONFI NAND CHIP
UNSUPPORTED NAND CHIP
%s: CMDREG=%08x val=%08x
brcmnand_ctrl_read: Invalid register value %08x
%s: offset=%0llx  cs=%d ldw = %08x, udw = %08x
Found NAND on CS%1d: ACC=%08lx, cfg=%08lx, flashId=%08lx, tim1=%08lx, tim2=%08lx
%08x:
  %08x
NULL
%02x
%04x: 
OOB Register:
%08x 
brcmnand_memcpy32 src=%p not DW aligned
brcmnand_memcpy32 len=%d not DW aligned
brcmnand_to_flash_memcpy32 dest=%p not DW aligned
BUG: failure at %s:%d/%s()!
brcmnand_base.c
BUG!
brcmnand_to_flash_memcpy32 len=%d not DW aligned
%s: flash=%p, len=%d, src=%p
-->%s
%s: Correctable ECC error at %08x:%08x
-->%s, raw=%d
%s: offset=%0llx
<--%s: ret = %d
<--%s: ret = TIMEOUT
%s: INTF Status = %08x
%s at offset %llx
NAND registers snapshot 
%s: dwoob=%08x
%s: offset=%0llx, erased=%d, allFF=%d
p8[%d]=%02x
%s: offset=%0llx, i=%d from %d to %d, eccOobSize=%d, eccbytes=%d, erased=%d, allFF=%d
BUG: Unsupported ECC level %d
<-- %s: ret -EBADMSG
%s: Uncorrectable error at offset %llx
Data:
Spare Area
Turn on WR_PREEMPT_EN
TODO - Warning: Sometimes gdebug has +ive value in %s.
       gdebug is set to 0 temporarilly to avoid debug traces!!!
%s: offset=%0llx, oobarea=%p
%s: offset %08x is not cache aligned, sliceOffset=%08lx, CacheSize=%d
%s: offset=%0llx, oob=
brcmnand_cache_is_valid returns 0
<-- %s: offset=%0llx
-->%s: offset=%0llx
%s: offset %0llx is not cache aligned
--> %s: offset=%0llx
%s: oob=
%s: Flash Status Error @%0llx
%s: Timeout
-->%s, offset=%0llx
-->%s, page=%0llx
%s 1: calling brcmnand_posted_read_cache returns %d
%s: 3: brcmnand_posted_read_cache failed at offset=%0llx, ret=%d
%s 2: calling brcmnand_posted_read_oob returns %d
%s: 3: posted read oob failed at offset=%0llx, ret=%d
%s returns %d
<--%s offset=%0llx, ret=%d
%s: brcmnand_posted_write_cache failed at offset=%0llx, ret=%d
nand_write: Attempt to write not page aligned data
%s: brcmnand_posted_write_oob failed at offset=%0llx, ret=%d
<--%s offset=%0llx
-->%s, to=%08x, len=%d
%s: Unaligned address
%s: Erase past end of device, instr_addr=%016llx, instr->len=%08x, mtd->size=%16llx
%s: attempt to erase a bad block at addr 0x%08x
brcmnand_erase: Failed erase, block %d, flash status=%08x
%s: Marking bad block @%08x
Mark SLC flash as bad at offset %0llx, badblockpos=%d
Mark MLC flash as bad at offset %0llx
Mark bad page %d failed with retval=%d
BrcmNAND mfg %x %x %s %dMB on CS%d
Block size=%08x, erase shift=%d
Un-supported page size 8KB
NAND Config: Reg=%08x, chipSize=%d MB, blockSize=%dK, erase_shift=%x
busWidth=%d, pageSize=%dB, page_shift=%d, page_mask=%08x
Adjust timing1: Was %08lx, changed to %08lx
timing1 not adjusted: %08lx
Adjust timing2: Was %08lx, changed to %08lx
timing2 not adjusted: %08lx
eccLevel=%d, 1Ksector=%d, oob=%d
nbrBitsPerCell=%d, cellinfo=%d, chip->cellinfo=%08x
<--%s: acc b4: %08x, after: %08x
NAND ACC CONTROL on CS%1d changed to %08x, from %08lx,
ECC level changed to %d
OOB size changed to %d
Flash type changed to MLC
B4: NandSelect=%08x, nandConfig=%08x, chipSelect=%d
%s: CS%1d: dev_id=%08x
After: NandSelect=%08x, nandConfig=%08x
4th ID Byte: Device requiring Controller V3.0 in database, but not handled
Flash Cache:
%s: waitfor=%d, Got ctrl-busy, intfc=%08x
prev_ready=%08x, ready=%08x
%s: waitfor=%d, return %d, intfc=%08x
-->%s, chipSelect=%d
%s: Cannot read across DW boundary ofs=%d, size=%d
%s: OFS=%d, EBIAddr=%08x val=%08x, p8=%02x%02x%02x%02x
%s: Found ONFI signature.  Looking for %08x found %08x, ret=%d
%s: Cannot find ONFI signature.  Looking for %08x found %08x
Original nand_config=%08x, ONFI nand_config=%08x
%s: EXT PARAM not found, looking for %08x, found %08x
reqEcc=%d, codeWork=%d
NAND Flash not detected
DevId %08x may not be supported.  Will use config info
%s: Ecc level set to %d, sectorSize=%d from ID table
Spare Area Size = %dB/512B
BrcmNAND version = 0x%04x %dMB @%08lx
NAND_CS_NAND_XOR=%08x
ECC level from command line=%d
Corrected ECC on block-n to ECC on block-0: ACC = %08lx from %08lx
Corrected ECC on block-0 to ECC on block-n: ACC = %08lx from %08lx
%s: default CORR ERR threshold  %d bits
%s: CORR ERR threshold set to %d bits
Only BCH-4 or better is supported on MLC flash
Corrected ECC to BCH-4 for MLC flashes: ACC_CONTROL = %08lx from %08lx
ACC: %d OOB bytes per 512B ECC step; from ID probe: %d
BCH-12 requires >=27 OOB bytes per ECC step.
Please fix your board straps. Aborting to avoid file system damage
Flash says it has %d OOB bytes, eccLevel=%lu, but board strap says %d bytes, fixing it...
ACC_CONTROL adjusted to %08x
Unsupported ECC level %lu
reqEccLevel=%d, eccLevel=%d
******* Insufficient ECC level, required=%d, strapped for %d ********
mtd->oobsize=%d, mtd->eccOobSize=%d
%s: B4 nand_select = %08x
%s: After nand_select = %08x
Setting NAND_COMPLEX_OOB_WRITE
Corrected for NOP=1: ACC_CONTROL = %08x
page_shift=%d, bbt_erase_shift=%d, chip_shift=%d, phys_erase_shift=%d
Brcm NAND controller version = %x.%x NAND flash size %dMB @%08x
ECC layout=brcmnand_oob_bch4_512
Unsupported ECC level for page size of %d
Unsupported page size of %d
ECC layout=brcmnand_oob_bch4_2k
ECC layout=brcmnand_oob_bch8_16_2k
ECC layout=brcmnand_oob_bch4_4k
Unsupported ECC code %d with only 64B OOB per page
ECC layout=brcmnand_oob_bch8_16_4k
ECC layout=brcmnand_oob_bch8_27_4k
ECC layout=brcmnand_oob_bch12_27_4k
Unsupported ECC code %d for MLC with pageSize=%d
ECC layout=brcmnand_oob_128
ECC layout=brcmnand_oob_bch8_4k
ECC layout=brcmnand_oob_bch4_8k
ECC layout=brcmnand_oob_bch8_16_8k
ECC layout=brcmnand_oob_bch8_27_8k
ECC layout=brcmnand_oob_bch12_27_8k
%s:  mtd->oobsize=%d
%s: oobavail=%d, eccsize=%d, writesize=%d
%s, eccsize=%d, writesize=%d, eccsteps=%d, ecclevel=%d, eccbytes=%d
Invalid ecc parameters
%s: bnand->ecclevel = %d
%s my func =>TESTING<=
brcmnand_bbt: Error reading bad block table
%s: ECC error %d while reading bad block table
nand_read_bbt: Reserved block at 0x%08x
nand_read_bbt: Bad block at 0x%08x
Bad block table at page %x, version 0x%02X
########## %s: read_oob returns %d
Scanning device for bad blocks, options=%08x
brcmnand_create_bbt(): chipnr (%d) > available chips (%d)
Bad eraseblock %d at 0x%08x
Bad block table %c%c%c%c not found for chip on CS%d
Bad block table %c%c%c%c found at page %08lx, version 0x%02X for chip on CS%d
No space left to write bad block table %c%c%c%c
nand_bbt: Error reading block for writing the bad block table
nand_bbt: ECC error while reading block for writing bad block table
brcmnand_bbt: Error during block erase at %0llx: %d
write_bbt returns flash status error at %0llx, skipping and retrying...
Bad block table written to 0x%08x, version 0x%02X
brcmnand_bbt: Error while writing bad block table %d
brcmnand_scan_bbt: Out of memory, bbt_erase_shift=%d, len=%d
brcmnand_bbt: Can't scan flash and build the RAM-based BBT
%s: Out of memory 2, bbt_erase_shift=%d, len=%dx
brcmnand_update_bbt: Out of memory
----- Contents of BBT -----
Bad block at %0llx
----- END Contents of BBT -----
%s: gClearBBT=clearbbt, start=%0llx, end=%0llx
Erasing flash from %016llx to %016llx
BUG: failure at %s:%d/%s()!
brcmnand_bbt.c
BUG!
%s: Erase failure, marking bad block @%016llx
rescanning .... 
Found bad block at offset %0llx
brcmnand_read_pageoob returns %d for page %0llx
Skipping Bad Block at %0llx
%s: Marking bad block @%0llx
Invalid brcmnand argument in %s
%s: Cannot allocate memory for BBT descriptor
-->%s
%s: bbt_td = bbt_main_descr
%s: bbt_td = bbt_bch8_16_main_descr
%s: bbt_td = bbt_bch4_main_descr
%s: bbt_td = bbt_slc_bch4_main_descr
***** %s: Unsupported ECC level %d
ubi%d
UBI error: %s: cannot register UBI character devices
UBI error: %s: cannot add character device
UBI error: %s: cannot add volume %d
UBI error: %s: cannot initialize UBI %s, error %d
UBI error: %s: multiple regions, not implemented
UBI error: %s: min. I/O unit (%d) is not power of 2
UBI error: %s: unaligned VID header shift %d
UBI error: %s: bad VID header (%d) or data offsets (%d)
UBI warning: %s: EC and VID headers are in the same minimal I/O unit, switch to read-only mode
UBI: MTD device %d is write-protected, attach in read-only mode
UBI: physical eraseblock size:   %d bytes (%d KiB)
UBI: logical eraseblock size:    %d bytes
UBI: smallest flash I/O unit:    %d
UBI: sub-page size:              %d
UBI: VID header offset:          %d (aligned %d)
UBI: data offset:                %d
UBI error: %s: cannot clean auto-resize flag for volume %d
UBI error: %s: cannot auto-resize volume %d
UBI: volume %d ("%s") re-sized from %d to %d LEBs
UBI error: %s: refuse attaching mtd%d - it is already emulated on top of UBI
UBI: attaching mtd%d to ubi%d
UBI error: %s: cannot spawn "%s", error %d
UBI: attached mtd%d to ubi%d
UBI: MTD device name:            "%s"
UBI: MTD device size:            %llu MiB
UBI: number of good PEBs:        %d
UBI: number of bad PEBs:         %d
UBI: max. allowed volumes:       %d
UBI: wear-leveling threshold:    %d
UBI: number of internal volumes: %d
UBI: number of user volumes:     %d
UBI: available PEBs:             %d
UBI: total number of reserved PEBs: %d
UBI: number of PEBs reserved for bad PEB handling: %d
UBI: max/mean erase counter: %d/%d
UBI error: %s: %s reference count %d, destroy anyway
UBI: mtd%d is detached from ubi%d
UBI error: %s: too many MTD devices, maximum is %d
UBI error: %s: cannot create UBI class
UBI error: %s: cannot create sysfs file
UBI error: %s: cannot register device
UBI error: %s: cannot attach mtd%d
UBI error: %s: UBI error: cannot initialize UBI, error %d
UBI error: incorrect bytes count: "%s"
UBI error: too many parameters, max. is %d
UBI error: parameter "%s" is too long, max. is %d
UBI warning: empty 'mtd=' parameter - ignored
UBI error: too many arguments at "%s"
UBI error: %s: bad CRC at record %u: %#08x, not %#08x
UBI error: %s: volumes %d and %d have the same name "%s"
UBI error: %s: volume table check failed: record %d, error %d
UBI: create volume table (copy #%d)
UBI warning: %s: volume table copy #2 is corrupted
UBI: volume table was restored
UBI error: %s: both volume tables are corrupted
UBI warning: %s: volume table copy #1 is corrupted
UBI error: %s: more then one auto-resize volume (%d and %d)
UBI warning: %s: static volume %d misses %d LEBs - corrupted
layout volume
UBI error: %s: not enough PEBs, required %d, available %d
UBI error: %s: bad scanning information, error %d
UBI error: %s: scanning found %d volumes, maximum is %d + %d
UBI error: %s: too large volume ID %d found by scanning
UBI: finish volume %d removal
UBI error: %s: the layout volume was not found
UBI error: %s: cannot add character device
%s_%d
UBI error: %s: cannot register device
UBI error: %s: cannot create volume %d, error %d
UBI: reserve more %d PEBs
UBI error: %s: cannot remove volume %d, error %d
UBI error: %s: cannot add character device for volume %d, error %d
UBI warning: %s: volume %d on UBI device %d is corrupted
UBI warning: %s: mark volume %d as corrupted
UBI warning: %s: switch to read-only mode
UBI warning: %s: bad VID header at PEB %d, LEB%d:%d
UBI: force data checking
UBI warning: %s: CRC error: calculated %#08x, must be %#08x
UBI: recover PEB %d, move data to PEB %d
UBI: data was successfully recovered
UBI warning: %s: failed to write to PEB %d
UBI: try again
UBI warning: %s: failed to write data to PEB %d
UBI warning: %s: failed to write VID header to LEB %d:%d, PEB %d
UBI warning: %s: failed to write %d bytes at offset %d of LEB %d:%d, PEB %d
UBI: try another PEB
UBI warning: %s: failed to write %d bytes of data to PEB %d
UBI warning: %s: error %d while reading data from PEB %d
UBI warning: %s: cannot read VID header back from PEB %d
UBI warning: %s: cannot read data back from PEB %d
UBI warning: %s: read data back from PEB %d - it is different
UBI error: %s: no enough physical eraseblocks (%d, need %d)
UBI warning: %s: cannot reserve enough PEBs for bad PEB handling, reserved %d, need %d
UBI: fixable bit-flip detected at PEB %d:%d
UBI error: %s: error %d while reading %d bytes from PEB %d:%d, read %zd bytes
%s[%d] not here
UBI error: %s: read-only mode
UBI error: %s: error %d while writing %d bytes to PEB %d:%d, written %zd bytes
UBI error: %s: cannot erase PEB %d, error %d
UBI error: %s: interrupted PEB %d erasure
UBI error: %s: cannot erase PEB %d
UBI error: %s: erased PEB %d, but a non-0xFF byte found
UBI error: %s: pattern %x checking failed for PEB %d
UBI error: %s: read problems on freshly erased PEB %d, must be bad
UBI error: %s: error %d while checking if PEB %d is bad
UBI error: %s: cannot mark PEB %d bad, error %d
UBI error: %s: node with incompatible UBI version found: this UBI version is %d, image version is %d
UBI error: %s: bad VID header offset %d, expected %d
UBI error: %s: bad data offset %d, expected %d
UBI error: %s: bad erase counter %lld
UBI error: %s: bad EC header
UBI warning: %s: no EC header found at PEB %d, only 0xFF bytes
UBI warning: %s: bad magic number at PEB %d: %08x instead of %08x
UBI warning: %s: bad EC header CRC at PEB %d, calculated %#08x, read %#08x
UBI error: %s: validation failed for PEB %d
UBI error: %s: bad VID header
UBI warning: %s: no VID header found at PEB %d, only 0xFF bytes
UBI warning: %s: bad CRC at PEB %d, calculated %#08x, read %#08x
UBI warning: %s: switch to read-only mode
UBI error: %s: work failed with error code %d
UBI error: %s: no free eraseblocks
BUG: failure at %s:%d/%s()!
wl.c
BUG!
UBI error: %s: erase counter overflow at PEB %d, EC %llu
UBI error: %s: error %d while reading VID header from PEB %d
UBI error: %s: error %d while moving PEB %d to PEB %d
UBI error: %s: failed to erase PEB %d, error %d
UBI error: %s: bad physical eraseblock %d detected
UBI: reserve more %d PEBs
UBI error: %s: no reserved physical eraseblocks
UBI: mark PEB %d as bad
UBI warning: %s: last PEB from the reserved pool was used
UBI error: %s: PEB %d not found
UBI: schedule PEB %d for scrubbing
UBI: background thread "%s" started, PID %d
UBI error: %s: %s: work failed with error code %d
UBI: %s: %d consecutive failures
ubi_bgt%dd
UBI error: %s: no enough physical eraseblocks (%d, need %d)
BUG: failure at %s:%d/%s()!
scan.c
BUG!
UBI error: %s: inconsistent VID header at PEB %d
UBI error: %s: PEB %d and PEB %d have the same version %lld
UBI error: %s: two LEBs with same version %u
UBI error: %s: two LEBs with same sequence number %llu
UBI error: %s: erase counter overflow at PEB %d, EC %d
UBI error: %s: no eraseblocks found
UBI error: %s: this UBI version is %d, image version is %d
UBI error: %s: erase counter overflow, max is %d
UBI: "delete" compatible internal volume %d:%d found, remove it
UBI: read-only compatible internal volume %d:%d found, switch to read-only mode
UBI: "preserve" compatible internal volume %d:%d found
UBI error: %s: incompatible internal volume %d:%d found
UBI: empty MTD device detected
gmii
sgmii
rmii
rgmii
rgmii-id
rgmii-rxid
rgmii-txid
rtbi
xgmii
softc has not been initialized.
Disabling Switch ports.
Flushing Receive Buffers...
dmaFlag (return -1)[%04x]
%lu buffers found.
Closing DMA Channels.
Rx Timeout !!!
Tx Timeout !!!
No inpstat buffer
No dst buffer
src buffer too large.
size is %d
No tx BD available ?!
BCM63xx : Failed to allocate softc memory.
BCM63xx : Failed to allocate txBds memory.
BCM63xx : Failed to allocate rxBds memory.
BCM63xx : Failed to allocate RxBuffer memory.
BCM63xx : Failed to allocate txBuffer memory.
BCM63xxx
BCM63xx : unregistering Ethernet driver 
%.3s %.3s %.2d %.2d:%.2d:%.2d %d
get_fl_mem: unknown device type, using raw offset!
NONE
ZERO
RTIME
RUBINMIPS
COPY
DYNRUBIN
ZLIB
add_node: malloc failed
add_node failed!
%s %08x
UNKNOWN COMPRESSION METHOD = 
 ** ERROR ** 
%*.*s
 has dup version =
 %s %8ld %s %s
 -> 
find_inode failed for name=
 has dup version (resolve) = 
Scanning JFFS2 FS:   
offset %08x already seen, skip
OOPS Cleanmarker has bad size %d != %zu
OOPS Padding has bad size %d < %zu
Unknown node type: %x len %d offset 0x%x
 done.
%s: Failed to scan JFFSv2 file structure
ls: Failed to scan jffs2 file structure
load
load: Failed to find inode
load: Failed to resolve inode structure
load: Failed to read inode
info
Compression: %s
	frag count: %d
	compressed sum: %d
	uncompressed sum: %d
%.3s %.3s %.2d %.2d:%.2d:%.2d %d
no compression
zlib
deflate
UBIFS error (pid %d): %s: invalid compression type %d
UBIFS error (pid %d): %s: %s compression is not compiled in
UBIFS error (pid %d): %s: cannot decompress %d bytes, compressor %s, error %d
<DIR>	
<LNK>	
other	
%s: Error in ubifs_iget(), ino=%lld ret=%p!
%9lld  %24.24s  
UBIFS error (pid %d): %s: cannot find next direntry, error %d
%s: Error, no memory for malloc!
Symlink recursion, aborting
%s/%s
UBIFS error (pid %d): %s: bad data node (block %u, inode %lu)
%s: Error, malloc fails!
UBIFS error (pid %d): %s: cannot read page %lu of inode %lu, error %d
%s: Error reading inode %ld!
Loading file '%s' to addr 0x%08x with size %d (0x%08x)...
Error reading file '%s'
filesize
Done
UBIFS warning (pid %d): %s: switched to read-only mode, error %d
UBIFS error (pid %d): %s: bad magic %#08x, expected %#08x
UBIFS error (pid %d): %s: bad node type %d
UBIFS error (pid %d): %s: bad CRC: calculated %#08x, read %#08x
UBIFS error (pid %d): %s: bad node length %d
UBIFS error (pid %d): %s: bad node at LEB %d:%d
UBIFS error (pid %d): %s: sequence number overflow %llu, end of life
UBIFS warning (pid %d): %s: running out of sequence numbers, end of life soon
UBIFS error (pid %d): %s: cannot read node %d from LEB %d:%d, error %d
UBIFS error (pid %d): %s: bad node type (%d but expected %d)
UBIFS error (pid %d): %s: expected node type %d
UBIFS error (pid %d): %s: bad node length %d, expected %d
UBIFS error (pid %d): %s: inode is too large (%lld)
UBIFS error (pid %d): %s: unknown compression type %d
UBIFS warning (pid %d): %s: inode %lu uses '%s' compression, but it was not compiled in
UBIFS error (pid %d): %s: Error, can't lock (save) more inodes while recovery!!!
UBIFS error (pid %d): %s: inode %lu validation failed, error %d
UBIFS error (pid %d): %s: failed to read inode %lu, error %d
UBIFS warning (pid %d): %s: UBI volume is corrupted - read-only mode
UBIFS: read-only UBI device
UBIFS: static UBI volume - read-only mode
UBIFS error (pid %d): %s: too small LEBs (%d bytes), min. is %d bytes
UBIFS error (pid %d): %s: too few LEBs (%d), min. is %d
UBIFS error (pid %d): %s: bad min. I/O size %d
UBI volume
mount
UBIFS error (pid %d): %s: can't format empty UBI volume: read-only %s
UBIFS error (pid %d): %s: cannot mount read-write - read-only media
UBIFS error (pid %d): %s: 'compressor "%s" is not compiled in
ubifs_bgt%d_%d
UBIFS: recovery needed
UBIFS: recovery deferred
UBIFS: recovery completed
UBIFS: mounted UBI device %d, volume %d, name "%s"
UBIFS: mounted read-only
UBIFS: file system size:   %lld bytes (%lld KiB, %lld MiB, %d LEBs)
UBIFS: journal size:       %lld bytes (%lld KiB, %lld MiB, %d LEBs)
UBIFS: media format:       w%d/r%d (latest is w%d/r%d)
UBIFS: default compressor: %s
UBIFS: reserved for root:  %llu bytes (%llu KiB)
UBIFS error (pid %d): %s: the file-system is not R/W-compatible
UBIFS: on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d
UBIFS error (pid %d): %s: cannot open "%s", error %d
ubifs
Error reading superblock on volume '%s'!
ubi:
UBIFS error (pid %d): %s: min. I/O unit mismatch: %d in superblock, %d real
UBIFS error (pid %d): %s: LEB size mismatch: %d in superblock, %d real
UBIFS error (pid %d): %s: bad LEB count: %d in superblock, %d on UBI volume, %d minimum required
UBIFS error (pid %d): %s: max. LEB count %d less than LEB count %d
UBIFS error (pid %d): %s: bad superblock, error %d
No UBIFS filesystem found!
UBIFS error (pid %d): %s: on-flash format version is w%d/r%d, but software only supports up to version w%d/r%d
UBIFS: only R/O mounting is possible
UBIFS error (pid %d): %s: on-flash format version %d is not supported
UBIFS error (pid %d): %s: unsupported key format
UBIFS error (pid %d): %s: bad master node at offset %d error %d
UBIFS error (pid %d): %s: bad leb_cnt on master node
UBIFS error (pid %d): %s: too few LPT LEBs
UBIFS error (pid %d): %s: LPT ltab too big
UBIFS error (pid %d): %s: invalid crc in LPT node: crc %hx calc %hx
UBIFS error (pid %d): %s: invalid type (%d) in LPT node type %d
UBIFS error (pid %d): %s: error %d reading nnode at %d:%d
UBIFS error (pid %d): %s: error %d reading pnode at %d:%d
UBIFS error (pid %d): %s: bad pad node at LEB %d:%d
UBIFS error (pid %d): %s: cannot read %d bytes from LEB %d:%d, error %d
UBIFS error (pid %d): %s: corrupted data at LEB %d:%d
UBIFS error (pid %d): %s: corrupt empty space at LEB %d:%d
UBIFS error (pid %d): %s: LEB %d scanning failed
UBIFS error (pid %d): %s: old idx added twice!
UBIFS error (pid %d): %s: cannot read node type %d from LEB %d:%d, error %d
UBIFS error (pid %d): %s: bad node type (%d but expected %d)
UBIFS error (pid %d): %s: expected node type %d
UBIFS error (pid %d): %s: bad node length %d, expected %d
UBIFS error (pid %d): %s: bad key in node at LEB %d:%d
UBIFS error (pid %d): %s: bad node at LEB %d:%d
UBIFS error (pid %d): %s: buffer too small %d vs %d
UBIFS error (pid %d): %s: failed to read from LEB %d:%d, error %d
UBIFS error (pid %d): %s: bad indexing node at LEB %d:%d, error %d
UBIFS error (pid %d): %s: bad key in node at LEB %d:%d
UBIFS error (pid %d): %s: unmap LEB %d failed, error %d
UBIFS error (pid %d): %s: invalid node type %d in orphan area at %d:%d
UBIFS error (pid %d): %s: out of order commit number %llu in orphan node at %d:%d
UBIFS error (pid %d): %s: unmap LEB %d failed, error %d
UBIFS error (pid %d): %s: failed to recover master node
UBIFS error (pid %d): %s: corrupt empty space at LEB %d:%d
UBIFS error (pid %d): %s: LEB %d scanning failed
UBIFS error (pid %d): %s: failed to get CS sqnum
UBIFS error (pid %d): %s: unrecoverable log corruption in LEB %d
UBIFS error (pid %d): %s: unexpected empty space at %d:%d
UBIFS error (pid %d): %s: duplicate sqnum in replay
directory entry
extended attribute entry
UBIFS error (pid %d): %s: bad %s node
UBIFS error (pid %d): %s: bad key type %d
UBIFS error (pid %d): %s: file system's life ended
UBIFS error (pid %d): %s: bad truncation node
UBIFS error (pid %d): %s: unexpected node type %d in bud LEB %d:%d
BUG: failure at %s:%d/%s()!
replay.c
BUG!
UBIFS error (pid %d): %s: bad node is at LEB %d:%d
UBIFS error (pid %d): %s: duplicate sqnum in replay tree
UBIFS error (pid %d): %s: bud at LEB %d:%d was already referred
UBIFS error (pid %d): %s: unexpected node in log
UBIFS error (pid %d): %s: log error detected while replying the log at LEB %d:%d
UBIFS error (pid %d): %s: bad index head LEB %d:%d
%llu Bytes%s
.%ld
 %ciB%s
%08lx:
 %0*x
    %s
Error: Bad gzipped data
Error: gunzip out of data in header
1.2.3
Error: inflateInit2() returned %d
Error: inflate() returned %d
Env export buffer too small: %zu, but need %zu
himport_r: can't insert "%s=%s" into hash table
.%03ld
<NULL>
(null)
%s:%u: %s: Assertion `%s' failed.
invalid distance too far back
invalid distance code
invalid literal/length code
incorrect header check
unknown compression method
invalid window size
unknown header flags set
header crc mismatch
invalid block type
invalid stored block lengths
too many length or distance symbols
invalid code lengths set
invalid bit length repeat
invalid literal/lengths set
invalid distances set
incorrect data check
incorrect length check
need dictionary
stream end
file error
stream error
data error
insufficient memory
buffer error
incompatible version
bootfile
*** WARNING: %s is too long (%d - max: %d) - truncated
BOOTP broadcast %d
Host Name
Root Path
Opt Boot File
*** WARNING: using vendor optional boot file
*** Unhandled DHCP Option in OFFER/ACK: %d
DHCP client bound to address %pI4
DHCP: INVALID STATE
gmii
sgmii
rmii
rgmii
rgmii-id
rgmii-rxid
rgmii-txid
rtbi
xgmii
%s%daddr
%saddr
eth%dmacskip
ethmacskip
BUG: failure at %s:%d/%s()!
eth.c
BUG!
ethact
Warning: %s MAC addresses don't match:
Address in SROM is         %pM
Address in environment is  %pM
Board Net Initialization Failed
CPU Net Initialization Failed
Net Initialization Skipped
No ethernet found.
ethprime
 [PRIME]
Warning: eth device name has a space!
Warning: failed to set MAC address
ethrotate
unknown
## Warning: gatewayip needed but not set
ARP Retry count exceeded; starting again
autoload
ipaddr
gatewayip
netmask
serverip
nvlan
vlan
Abort
Bytes transferred = %ld (%lx hex)
filesize
fileaddr
netretry
once
Using %s device
 ICMP Host Redirect to %pI4 
bad length %d < %d
len bad %d < %d
checksum bad
*** ERROR: ping address not given
*** ERROR: `serverip' not set
*** ERROR: `ipaddr' not set
*** ERROR: No ethernet found.
*** ERROR: `ethaddr' not set
*** ERROR: `eth%daddr' not set
%d.%d.%d.%d
none
%s; starting again
done
octet
timeout
blksize%c%d%c
File too large
File has bad magic
blksize
TFTP error: First block is not block 1 (%ld)
Starting again
TFTP error: '%s' (%d)
Not retrying...
Starting again
Retry count exceeded
tftpblocksize
tftptimeout
TFTP timeout (%ld ms) too low, set minimum = 1000 ms
%02X%02X%02X%02X.img
*** Warning: no boot file name; using '%s'
Using %s device
TFTP %s server %pI4; our IP address is %pI4
from
; sending through gateway %pI4
Filename '%s'.
 Size is 0x%x Bytes = 
Load address: 0x%lx
Loading: *
FFFFFFFFFFFF4C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F334C4250726F33
251009981EDE7452E69D800533BB13FD128AB3485287C81401DD3BFDCF382308
%02X
Magic received
waitForMagic
Test WAIT_FOR_MAGIC function
WAIT_FOR_MAGIC
gpio in: 0x%x 
board type: %08x
board memsize : 0x%08x
CPU: Broadcom BCM%lX%lX
Unsupported cpu  proc_id=0x%08x
f3864 > 
f3865 > 
f5340 > 
f5350 > 
unknown > 
4add_one_partition
nand_select_chip
sb3_boot
add_to_list
sb3_test_mem
sb3_wait_for_magic
sb3_sagem_init
ubi_wl_get_peb
brcmnand_read_bbt
nand_transfer_oob
brcmnand_ctrl_read
brcmnand_scan_block_fast
nand_is_blk_cleanmarker
brcmnand_ctrl_write
brcmnand_ctrl_writeAddr
brcmnand_to_flash_memcpy32
brcmnand_ctrl_verify_ecc
brcmnand_spare_is_valid
brcmnand_cache_is_valid
brcmnand_ctrl_write_is_complete
nand_fill_oob
brcmnand_transfer_oob
brcmnand_post_mortem_dump
read_ext_spare_area
brcmnand_handle_false_read_ecc_unc_errors
bcm63xxx_nand_cmdfunc
bcm63xxx_nand_calculate_ecc
bcm63xxx_nand_correct_data
bcm63xxx_nand_enable_hwecc
brcmnand_scan_bbt
replay_bud
brcmnand_preprocessKernelArg
brcmnand_postprocessKernelArg
brcmnand_ctrl_posted_read_cache
nand_scan_tail
brcmnand_posted_read_oob
brcmnand_bbt_desc_init
brcmnand_default_bbt
brcmnand_ctrl_posted_write_cache
brcmnand_posted_write_oob
brcmnand_read_page
brcmnand_read_page_oob
brcmnand_write_page
brcmnand_fill_oob
brcmnand_write_page_oob
brcmnand_do_write_oob
brcmnand_erase_bbt
brcmnand_decode_config
brcmnand_set_acccontrol
brcmnand_read_id
brcmnand_flashcache_read
brcmnand_monitor_intfc
brcmnand_ONFI_decode
brcmnand_probe
handle_acc_control
brcmnand_scan
read_brcmnand_chip_eccbytes
brcmnand_block_markbad
set_default_env
env_import
do_env_export
saveenv
do_env_import
ubi_ro_mode
ubi_ro_mode
ubi_io_read
ubi_create_volume
validate_vid_hdr
vtbl_check
ubi_open_volume
do_work
ubi_io_write
uif_init
do_sync_erase
io_init
compare_lebs
torture_peb
ubi_leb_read
ubi_wl_get_peb
ubi_eba_read_leb
ubi_scan_add_used
ubi_io_sync_erase
ubi_io_is_bad
sync_erase
process_lvol
autoresize
ubi_io_mark_bad
recover_peb
validate_ec_hdr
ubi_attach_mtd_dev
ubi_io_read_ec_hdr
ubi_eba_write_leb
wear_leveling_worker
ubi_scan_erase_peb
init_volumes
ubi_add_volume
ubi_scan_get_free_peb
validate_vid_hdr
ubi_detach_mtd_dev
ubi_eba_write_leb_st
process_eb
ubi_init
erase_worker
ubi_io_read_vid_hdr
check_sv
ubi_wl_put_peb
check_scanning_info
ubi_eba_copy_leb
ubi_wl_scrub_peb
ubi_read_volume_table
ubi_eba_init_scan
ubi_wl_init_scan
ubi_remove_vol
ubi_volume_write
ubifs_leb_unmap
ubifs_leb_unmap
validate_sb
ubifs_tnc_levelorder_next
insert_old_idx
ubifs_check_node
ubifs_scan_a_node
validate_inode
validate_master
do_kill_orphans
ubifs_start_scan
iput
ubifs_decompress
ubifs_iget
ubifs_recover_master_node
ubifs_calc_lpt_geom
read_znode
ubifs_read_superblock
ubifs_read_node
ubifs_scanned_corruption
filldir
ubifs_scan
ubifs_printdir
init_constants_early
insert_node
ubifs_read_master
insert_dent
ubifs_finddir
init_constants_sb
try_read_node
ubifs_tnc_read_node
ubifs_validate_entry
replay_bud
check_lpt_crc
nand_get_flash_type
check_lpt_type
ubifs_ls
mount_ubifs
ubifs_recover_leb
read_block
insert_ref_node
brcmnand_ctrl_posted_read_cache
do_readpage
ubifs_load
get_cs_sqnum
validate_ref
fallible_resolve_collision
replay_log_leb
ubifs_recover_log_leb
ubifs_read_nnode
ubifs_umount
read_pnode
ubifs_replay_journal
ubifs_fill_super
ubifs_get_sb
(((((
AAAAAA
BBBBBB
?456789:;<=
 !"#$%&'()*+,-./0123
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
SunMonTueWedThuFriSat
SunMonTueWedThuFriSat
bootargs=### no default boot args ###
bootcmd=sb
bootdelay=3
baudrate=115200
ethaddr=00:01:02:03:04:05
ipaddr=192.168.1.1
serverip=192.168.1.10
mtdparts=mtdparts=nand:768k(bcm),125184k(partAll),5120k(data)
part_boot=partAll
part_main=partAll
netretry=once
_platform=sc_bcm63xxx
_tftp_ipl=tftpboot ${_platform}.fboot.fbin
_tftp_oldipl=tftpboot ${_platform}.oldfboot.fbin
_tftp_spl=tftpboot ${_platform}.sboot.sbin
_tftp_uboot=tftpboot ${_platform}.u-boot.bin
_tftp_olduboot=tftpboot ${_platform}.oldu-boot.bin
_tftp_pp=tftpboot ${_platform}.ppBIN
_tftp_oper=tftpboot ${_platform}.scos.oper.secure
_tftp_gsdf_oper=tftpboot ${_platform}.scos.oper.gsdf
_tftp_resc=tftpboot ${_platform}.scos.resc.secure
_tftp_gsdf_resc=tftpboot ${_platform}.scos.resc.gsdf
_select_boot=ubi part ${part_boot}
_select_main=ubi part ${part_main}
_ubi_eraze=nand erase 0xC0000 0x7A40000; run _select_main
_ubi_mkvol1=ubi create operational 0x1f00000 static
_ubi_mkvol2=ubi create permanent_param 0x1f000 static; ubi create rescue 0x1f00000 static
_write_ipl=nand erase 0x00000 0x20000; nand write 0x80400000 0x00000 0x9000
_write_oldipl=nand erase 0x00000 0x20000; nand write 0x80400000 0x00000 0x20000
_write_spl=ubi remove secondaryboot; ubi create secondaryboot ${filesize} static; ubi write 0x80400000 secondaryboot ${filesize} 
_write_uboot=ubi remove uboot; ubi remove bootenv; ubi create uboot ${filesize} static; ubi write 0x80400000 uboot ${filesize} 
_write_olduboot=nand erase 0x40000 0x80000; nand write 0x80400000 0x40000 0x60000
_write_pp=ubi remove permanent_param; ubi create permanent_param 0x1f000 static; ubi write 0x80400000 permanent_param ${filesize}
_write_oper=ubi remove operational; ubi create operational 0x1f00000 static; ubi write 0x80400000 operational ${filesize}
_write_resc=ubi remove rescue; ubi create rescue 0x1f00000 static; ubi write 0x80400000 rescue ${filesize}
ubi_init=run _ubi_eraze; run _ubi_mkvol1; run _ubi_mkvol2
reset_env=run _select_boot; ubi remove bootenv; ubi create bootenv 0x1f000
load_ipl=run _tftp_ipl _write_ipl 
load_oldipl=run _tftp_oldipl _write_oldipl 
load_spl=run _select_boot _tftp_spl _write_spl 
load_uboot=run _select_boot _tftp_uboot _write_uboot 
load_olduboot=run _tftp_olduboot _write_olduboot 
load_allboot=run _select_boot _tftp_uboot _tftp_spl _tftp_ipl _tftp_uboot _write_uboot _tftp_spl _write_spl _tftp_ipl _write_ipl
load_oldboot=run _select_boot _tftp_olduboot  _tftp_oldipl _tftp_olduboot _write_olduboot _tftp_oldipl _write_oldipl
load_pp=run _select_main _tftp_pp _write_pp 
load_oper=run _select_main _tftp_oper _write_oper 
load_gsdf_oper=run _select_main _tftp_gsdf_oper _write_oper 
load_resc=run _select_main _tftp_resc _write_resc 
load_gsdf_resc=run _select_main _tftp_gsdf_resc _write_resc 
nand
@0123456789ABCDEF
L0123456789abcdef
JanFebMarAprMayJunJulAugSepOctNovDecJanFebMarAprMayJunJulAugSepOctNovDecEPTGMK
e03f<ij??ji<f30ef30e?ji<<ij?e03f
i<?j0ef33fe0j?<i
j?<i3fe00ef3i<?jj?<i3fe00ef3i<?j
i<?j0ef33fe0j?<i
f30e?ji<<ij?e03fe03f<ij??ji<f30e
%02X
TLS Web Server Authentication
TLS Web Client Authentication
Code Signing
E-mail Protection
Time Stamping
OCSP Signing
%d.%d
%02X%s
0x%02X=
emailAddress=
%sCRL version   : %d
%sissuer name   : 
%sthis update   : %04d-%02d-%02d %02d:%02d:%02d
%snext update   : %04d-%02d-%02d %02d:%02d:%02d
%sRevoked certificates:
%sserial number: 
 revocation date: %04d-%02d-%02d %02d:%02d:%02d
%ssigned using  : RSA+
SHA1
SHA224
SHA256
SHA384
SHA512
%scert. version : %d
%sserial number : 
%ssubject name  : 
%sissued  on    : %04d-%02d-%02d %02d:%02d:%02d
%sexpires on    : %04d-%02d-%02d %02d:%02d:%02d
%sRSA key size  : %d bits
-----BEGIN PUBLIC KEY-----
-----END PUBLIC KEY-----
-----BEGIN RSA PRIVATE KEY-----
-----END RSA PRIVATE KEY-----
-----BEGIN PRIVATE KEY-----
-----END PRIVATE KEY-----
%2d%2d%2d%2d%2d%2d
%4d%2d%2d%2d%2d%2d
-----BEGIN X509 CRL-----
-----END X509 CRL-----
-----BEGIN CERTIFICATE-----
-----END CERTIFICATE-----
Proc-Type: 4,ENCRYPTED
        
U-Boot 2011.12
Version: 4.3.0-full (Mar 20 2013 - 14:32:35) 
Copyright (C) 2011 - 2012 Sagemcom All rights reserved
ysky{
5d2K~
eJ'6?
7Y13
48Bbt0Bbt01tbB1tbB
Micron MT29F1G08AAC
USamsung K9F5608U0
 vST NAND512W3A2CN6
ST NAND01GW3B2CN6
Micron MT29F1G08AAC
Hynix H27U1G8F2B
vHynix H27U518S2C
nand0=nand
mtdparts=nand:768k(bcm),125184k(partAll),5120k(data)
nand0,0
mtd=1
partAll
md 0x8ff00000 0x1f00000
nand0
mtd=1
 n;^
Qkkbal
i]Wb
9a&g
MGiI
wn>Jj
#.zf
+o*7
md 0x8ff00000 0x1f00000
5md 0x8ff00000 0x1f00000
ww""
b	Rb
@-xe
USU,
l,%y
QD00
%EH 7
0X6H
!I6Df
1/A$
7zKr
(O)P
